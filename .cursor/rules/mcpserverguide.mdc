---
description: This guide provides a concise overview of how to implement an Anthropic Model Context Protocol (MCP) server that offers tools in TypeScript. It focuses specifically on the core aspects needed to create a functional MCP server.
globs: 
alwaysApply: false
---
# MCP Server Implementation Guide: Tools via HTTP & stdio

This guide details how to build an Anthropic Model Context Protocol (MCP) server in TypeScript to expose **Tools**. It utilizes the high-level `@modelcontextprotocol/sdk`'s `McpServer` API for simplicity and Zod for robust input schema definition and validation.

It covers two common transport methods:
1.  **Stateless Streamable HTTP:** For network-accessible servers.
2.  **stdio:** For direct command-line integration.

**Target Audience:** Proficient AI Coders new to MCP.

## 1. Core Concept: `McpServer` and Tools

The `McpServer` class (`@modelcontextprotocol/sdk/server/mcp.js`) provides a streamlined way to define server capabilities. We focus on `server.tool()`.

```typescript
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { z } from "zod"; // For schema definition

// Example: Define input schema for a tool
const AddNumbersSchema = z.object({
  a: z.number(),
  b: z.number(),
});

/**
 * Creates and configures the MCP server instance.
 * Define all your tools within this function.
 */
function createMcpServer(): McpServer {
  const server = new McpServer({
    // Basic server metadata
    name: "my-tool-server",
    version: "1.0.0",
  });

  // Define a tool using server.tool()
  server.tool(
    "add_numbers",     // Unique tool name
    AddNumbersSchema,  // Zod schema for input validation
    async ({ a, b }) => { // Handler receives parsed & validated arguments
      // --- Tool Logic ---
      const result = a + b;
      console.log(`Tool 'add_numbers' executed: ${a} + ${b} = ${result}`);

      // --- Return result in MCP format ---
      // Must return { content: [{ type: "text", text: ... }] }
      // For errors, return { content: [...], isError: true }
      return {
        content: [{ type: "text", text: String(result) }],
      };
      // Note: McpServer handles Zod validation errors automatically.
      // Catch other specific errors within your handler if needed.
    }
  );

  // Define other tools similarly:
  // server.tool("get_weather", GetWeatherSchema, async ({ location }) => { ... });

  return server;
}
```

## 2. Running the Server: Transports

Choose a transport based on `process.env.MCP_TRANSPORT` (`http` or `stdio`).

### Option A: Stateless Streamable HTTP

Uses `express` to handle HTTP requests. Each request gets a new, isolated server and transport instance.

```typescript
import express from 'express';
import { StreamableHTTPServerTransport } from "@modelcontextprotocol/sdk/server/streamableHttp.js";
// Assume createMcpServer is defined as above

async function runHttpServer() {
  // Get port from environment or use default 3123
  const PORT = parseInt(process.env.MCP_PORT || '3123', 10);

  const app = express();
  app.use(express.json()); // Middleware to parse JSON bodies

  // Main MCP endpoint
  app.post('/mcp', async (req, res) => {
    console.log("Received POST /mcp");
    // Create instances per-request for stateless operation
    let server: McpServer | null = null;
    let transport: StreamableHTTPServerTransport | null = null;
    try {
      server = createMcpServer();
      transport = new StreamableHTTPServerTransport({
        sessionIdGenerator: undefined, // Crucial for stateless mode
      });

      await server.connect(transport); // Connect logic to transport
      await transport.handleRequest(req, res, req.body); // Process the request

      // Clean up when client closes connection
      res.on('close', () => {
        console.log("Client connection closed, cleaning up.");
        transport?.close();
        server?.close();
      });
    } catch (error) {
      console.error('Error handling MCP request:', error);
      // Ensure cleanup even on error
      transport?.close();
      server?.close();
      if (!res.headersSent) {
        res.status(500).json({
          jsonrpc: '2.0',
          error: { code: -32603, message: 'Internal server error' },
          id: (req.body as any)?.id ?? null,
        });
      }
    }
  });

  // Handle other methods (optional but good practice)
  app.get('/mcp', (req, res) => res.status(405).send('Method Not Allowed'));
  app.delete('/mcp', (req, res) => res.status(405).send('Method Not Allowed'));

  app.listen(PORT, () => {
    console.log(`MCP Server (Stateless HTTP) listening on http://localhost:${PORT}/mcp`);
  });
}
```

### Option B: stdio

For direct command-line interaction (e.g., piping).

```typescript
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
// Assume createMcpServer is defined as above

async function runStdioServer() {
  console.error("Starting MCP Server on stdio..."); // Logs to stderr

  const server = createMcpServer();
  const transport = new StdioServerTransport();

  await server.connect(transport);

  console.error("MCP Server connected and running via stdio.");
  // The server will now listen for MCP JSON-RPC messages on stdin
  // and send responses/notifications on stdout.
}
```

## 3. Main Execution Logic

Combine the above options based on configuration.

```typescript
// Import necessary modules like express, McpServer, transports, z, etc.
// Include the createMcpServer function definition.
// Include runHttpServer and runStdioServer function definitions.

async function main() {
  // Default to 'http' if MCP_TRANSPORT is not set
  const transportType = process.env.MCP_TRANSPORT || 'http';

  console.log(`Attempting to start MCP server with transport: ${transportType}`);

  if (transportType === 'http') {
    await runHttpServer();
  } else if (transportType === 'stdio') {
    await runStdioServer();
  } else {
    console.error(`Error: Unknown MCP_TRANSPORT specified: '${transportType}'.`);
    console.error("Please set MCP_TRANSPORT to 'http' or 'stdio'.");
    process.exit(1);
  }
}

main().catch((error) => {
  console.error("Fatal error during server startup:", error);
  process.exit(1);
});
```

## Summary

1.  Define tool input schemas using **Zod**.
2.  Create an `McpServer` instance inside a reusable function (`createMcpServer`).
3.  Define tools on the server instance using `server.tool(name, schema, handler)`.
4.  Choose **transport**: `StreamableHTTPServerTransport` (stateless) or `StdioServerTransport`.
5.  Instantiate the chosen transport (configure HTTP port via `MCP_PORT` or default `3123`).
6.  For HTTP, use `express` and handle requests statelessly (new server/transport per request).
7.  Connect the server to the transport using `server.connect(transport)`.
8.  Use `process.env.MCP_TRANSPORT` to select the mode at runtime.

This provides a robust foundation for exposing tools via MCP. Remember to handle errors appropriately within your tool handlers.
